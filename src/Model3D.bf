using System;
using System.Diagnostics;
using RaylibBeef;

class Model3D
{
    public Model mModel;
    public Vector3 Position;
    public Vector3 Scale;
    public Vector3 Rotation;

    public this(String modelPath)
    {
        mModel = Raylib.LoadModel(modelPath);
        Position = .(0, 0, 0);
        Scale = .(1f, 1f, 1f);
        Rotation = .(0, 1, 0);
    }

    public ~this()
    {
        Raylib.UnloadModel(mModel);
    }

    public void Draw()
    {
        // Calculate transformation matrix from function parameters
        // Get transform matrix (rotation -> scale -> translation)
        Matrix matScale = Raymath.MatrixScale(Scale.x, Scale.y, Scale.z);
        Matrix matRotation = Raymath.MatrixRotate(.(0, 1, 0), Rotation.y * Raylib.DEG2RAD);
        Matrix matTranslation = Raymath.MatrixTranslate(Position.x, Position.y, Position.z);

        Matrix matTransform = Raymath.MatrixMultiply(Raymath.MatrixMultiply(matScale, matRotation), matTranslation);

        // Combine model transformation matrix (model.transform) with matrix generated by function parameters (matTransform)
        matTransform = Raymath.MatrixMultiply(mModel.transform, matTransform);

        for (int i = 0; i < mModel.meshCount; i++)
        {
            Color color = mModel.materials[((int32*)mModel.meshMaterial)[i]].maps[MaterialMapIndex.MATERIAL_MAP_ALBEDO].color;

            Color colorTint = color;// Raylib.GREEN;

            mModel.materials[((int32*)mModel.meshMaterial)[i]].maps[MaterialMapIndex.MATERIAL_MAP_ALBEDO].color = colorTint;
            Raylib.DrawMesh(mModel.meshes[i], mModel.materials[((int32*)mModel.meshMaterial)[i]], matTransform);
            mModel.materials[((int32*)mModel.meshMaterial)[i]].maps[MaterialMapIndex.MATERIAL_MAP_ALBEDO].color = color;
        }
    }
}